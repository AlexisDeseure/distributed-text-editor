#!/bin/sh
# the next line restarts using wish \
exec wish "$0" "$@"

# application tcl/tk illustrant la gestion simultanée
# - des actions initiées par l'utilisateur via l'interface
# - des réceptions de messages sur l'entrée standard
# - des timers
#
# (c) Bertrand.Ducourthial at utc.fr
#
# Fonctionnement :
#  chmod +x light.tk
#  cat | ./light.tk
# Ce qui est envoyé sur l'entrée standard est automatiquement pris en
# compte pour mettre à jour l'affichage.
# Ce qui est saisi via l'interface est envoyé sur la sortie standard.
# Le mode auto envoie périodiquement le dernier message saisi.


#### INITIALISATION DES VARIABLES GLOBALES ###########################
set var_ident 1
set var_message_recu "-"
set var_message_envoye "-"
set var_mode_auto false
set var_fonte_bouton -misc-*-*-r-*-*-14-*-*-*-*-*-*-*


#### LECTURES ASYNCHRONES ############################################
# lectures asynchrones non bloquantes et appel de la procedure
# proc_reception_message en cas de reception
fileevent stdin readable proc_reception_message
fconfigure stdin -blocking off


#### PROCEDURES ######################################################
# procedure appelee en cas de reception sur l'entree standard
proc proc_reception_message { } {
		# recuperation d'une variable de portee globale
		global var_message_recu

		# lecture de l'entree standard
		set var_message_recu [read -nonewline stdin]

		# modification de l'affichage
		.in.msg configure -text $var_message_recu -width 32
		update
}

# procedure appelee en cas de click sur le bouton envoyer
proc proc_emission_message { } {
		# recuperation d'une variable de portee globale
		global var_message_envoye

		# ecriture sur la sortie standard
		puts stdout $var_message_envoye
}

proc proc_aut_btdebut { } {
		global var_mode_auto .aut

		if { $var_mode_auto } {
				# passage de "emission en cours" a "aucune emission"

				# arret des emissions programmees
				after cancel proc_aut_emission

				# remise a l'etat initial des affichages
				.aut configure -text "Mode automatique \[état : désactivé\]"
				.bt.auto configure -text "Mode auto"

				set var_mode_auto false
		} else {
				# passage de "aucune emission" a "emission en cours"

				# mise a jour des affichages
				.aut configure -text "Mode automatique \[état : activé\]"
				.bt.auto configure -text "Fin auto"

				set var_mode_auto true

				proc_aut_emission
		}
}

proc proc_aut_emission { } {
		global var_aut_frq

		proc_emission_message

		# programmation de la prochaine emission
		after $var_aut_frq proc_aut_emission
						
}



#### DEFINITION DES ZONES DE L'INTERFACE #############################

wm title . $var_ident

#### zone pour l'emission
labelframe .out -pady 2 -padx 2 -text "Message à envoyer"
entry .out.msg -width 24 -textvariable var_message_envoye
pack .out.msg -side left -fill y -pady 2


#### zone pour la reception
labelframe .in -pady 2 -padx 2 -text "Message reçu"
label .in.msg -text $var_message_recu -width 32
pack .in.msg -side left -fill y -pady 2



#### zone des boutons
frame .bt
button .bt.quit -text "Quitter" \
		-activebackground red \
		-foreground red \
		-font $var_fonte_bouton \
		-width 10 \
		-command { exit }

button .bt.snd -text "Envoyer" \
		-activebackground SeaGreen4 \
		-foreground SeaGreen4 \
		-font $var_fonte_bouton \
		-width 10 \
		-command { proc_emission_message }

button .bt.auto -text "Mode auto" \
		-activebackground SeaGreen4 \
		-foreground SeaGreen4 \
		-font $var_fonte_bouton \
		-width 8 \
		-command proc_aut_btdebut

pack  .bt.quit .bt.snd .bt.auto -side right


### zone du timer
labelframe .aut -pady 2 -padx 2 -text "Emission périodique \[état : désactivé\]"

label .aut.lfrq -text "fréquence (ms) :"
spinbox .aut.sfrq -values "500 800 1000 2000 3000 5000 10000" -width 6 \
		-textvariable var_aut_frq

pack .aut.lfrq .aut.sfrq -side left -padx 2


#### affichage des zones horizontales
pack .bt .in .out .aut -fill both -expand yes -side top -pady 5


